/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* ROOT                := DEFINITION | IF | SELECT | LOOP | INCLUDE | STOP | END
* DEFINITION          := GLOBAL | LOCAL | CONST | DIM
* GLOBAL              := '[ ]*[gG][lL][oO][bB][aA][lL][ ]+' variable=VARIABLE '[ ]'? next=ROOT?
* LOCAL               := '[ ]*[lL][oO][cC][aA][lL][ ]+' variable=VARIABLE '[ ]'? next=ROOT?
* CONST               := '[ ]*[cC][oO][nN][sS][tT][ ]+' constant=VARIABLE '[ ]'? next=ROOT?
* DIM                 := '[dD][iI][mM]' VARIABLE
* IF                  := '[ ]*[iI][fF][ ]+' condition=CONDITION '[ ]+' '[tT][hH][eE][nN][ ]+'? VARIABLE '[ ]+[eE][nN][dD][ ]*[iI][fF]'?
* ELSE                := '[eE][lL][sS][eE]' | 'Else If' CONDITION | 'Else If' CONDITION 'Then'
* ELSE_TWO            := 'ElseIf' CONDITION | 'ElseIf' CONDITION 'Then'
* ENDIF               := 'EndIf'
* SELECT              := '[ ]*[sS][eE][lL][eE][cC][tT][ ]+' expression=EXPRESSION
* CASE                := '[ ]*[cC][aA][sS][eE][ ]+' VARIABLE+ | 'Case' EXPRESSION+
* DEFAULT             := '[ ]*[dD][eE][fF][aA][uU][lL][tT][ ]+'
* AFTER               := 'After' OBJECT_INDEX? VARIABLE
* BEFORE              := 'Before' OBJECT_INDEX? VARIABLE
* DELETE              := 'Delete' VARIABLE
* FIRST               := 'First' VARIABLE
* LAST                := 'Last' VARIABLE
* INSERT              := 'Insert' VARIABLE 'Before' VARIABLE | 'Insert' VARIABLE 'After' VARIABLE
* NEW                 := 'New' VARIABLE
* NULL                := 'Null'
* OBJECT              := 'Object.'TYPE
* TYPE                := 'Type' VARIABLE
* FIELD               := 'Field' VARIABLE
* OBJECT_INDEX        := ''
* END                 := '[eE][nN][dD]' | 'End Type' | 'End Function' | 'End If' | 'End Select'
* INCLUDE             := '[iI][nN][cC][lL][uU][dD][eE]' STRING_EXPRESSION
* STOP                := '[sS][tT][oO][pP]'
* DATA                := '[dD][aA][tT][aA]' EXPRESSION+
* LOOP                := FOR | WHILE | REPEAT
* FOR                 := '[ ]*[fF][oO][rR]' ASSIGNMENT 'To' NUMERIC_EXPRESSION | 'For' ASSIGNMENT 'To' NUMERIC_EXPRESSION 'Step' NUMERIC_EXPRESSION | 'For' VARIABLE '= Each' VARIABLE
* NEXT                := '[nN][eE][xX][tT]'
* WHILE               := '[ ]*[wW][hH][iI][lL][eE]' CONDITION '[ ]*[wW][eE][nN][dD]'
* REPEAT              := '[ ]*[rR][eE][pP][eE][aA][tT][ ]+' '[uU][nN][tT][iI][lL]' CONDITION | '[ ]*[rR][eE][pP][eE][aA][tT][ ]+' '[fF][oO][rR][eE][vV][eE][rR][ ]*'
* MAINLOOP            := '[ ]*[mM][aA][iI][nN][lL][oO][oO][pP][ ]*'
* FUNCTION            := '[ ]*[fF][uU][nN][cC][tT][iI][oO][nN]' VARIABLE '\(' PARAMETER* '\)'
* RETURN              := '[ ]*[rR][eE][tT][uU][rR][nN]' EXPRESSION?
* EXIT                := '[ ]*[eE][xX][iI][tT]'
* MOD                 := NUMERIC_EXPRESSION '[mM][oO][dD]' NUMERIC_EXPRESSION
* NOT                 := '[nN][oO][tT]' BOOLEAN_EXPRESSION
* AND                 := BOOLEAN_EXPRESSION '[aA][nN][dD]' BOOLEAN_EXPRESSION
* OR                  := BOOLEAN_EXPRESSION '[oO][rR]' BOOLEAN_EXPRESSION
* XOR                 := BOOLEAN_EXPRESSION '[xX][oO][rR]' BOOLEAN_EXPRESSION
* LABEL               := '.'VARIABLE
* RESTORE             := '[ ]*[rR][eE][sS][tT][oO][rR][eE]' LABEL
* READ                := '[ ]*[rR][eE][aA][dD]' VARIABLE+
* HANDLE              := '[ ]*[hH][aA][nN][dD][lL][eE]' VARIABLE
* SAR                 := NUMERIC_EXPRESSION '[sS][aA][rR]' NUMERIC_EXPRESSION
* SHL                 := NUMERIC_EXPRESSION '[sS][hH][lL]' NUMERIC_EXPRESSION
* SHR                 := NUMERIC_EXPRESSION '[sS][hH][rR]' NUMERIC_EXPRESSION
* DATA_TYPE           := NUMBER | STRING | BOOLEAN
* NUMBER              := '[+-]?[0-9]+' | '[pP][iI]'
* STRING              := '[a-z]+'
* BOOLEAN             := '[tT][rR][uU][eE]' | '[fF][aA][lL][sS][eE]'
* EXPRESSION          := NUMERIC_EXPRESSION | STRING_EXPRESSION | BOOLEAN_EXPRESSION | BOOLEAN | NUMBER | STRING
* NUMERIC_EXPRESSION  := NUMBER '\+' NUMBER | NUMBER '\-' NUMBER | NUMBER '\*' NUMBER | NUMBER '\/' NUMBER | NUMBER '\^' NUMBER
* STRING_EXPRESSION   := STRING | STRING '\+' STRING | STRING '\+' NUMBER | STRING '\+' BOOLEAN
* BOOLEAN_EXPRESSION  := BOOLEAN
* VARIABLE            := '[_a-zA-Z]+'
* VARIABLE_PLUS       := VARIABLE | VARIABLE',' VARIABLE_PLUS
* ASSIGNMENT          := VARIABLE = EXPRESSION
* PARAMETER           := VARIABLE | ASSIGNMENT
* CONDITION           := BOOLEAN_EXPRESSION | EXPRESSION '==' EXPRESSION | EXPRESSION '<' EXPRESSION | EXPRESSION '>' EXPRESSION | EXPRESSION '<=' EXPRESSION | EXPRESSION '>=' EXPRESSION | EXPRESSION '<>' EXPRESSION
*/
type Nullable<T> = T | null;
type $$RuleType<T> = (log?: (msg: string) => void) => Nullable<T>;
export interface ContextRecorder {
    record(pos: PosInfo, depth: number, result: any, negating: boolean, extraInfo: string[]): void;
}
interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    ROOT_1,
    ROOT_2,
    ROOT_3,
    ROOT_4,
    ROOT_5,
    ROOT_6,
    ROOT_7,
    DEFINITION_1,
    DEFINITION_2,
    DEFINITION_3,
    DEFINITION_4,
    GLOBAL,
    LOCAL,
    CONST,
    DIM,
    IF,
    ELSE_1,
    ELSE_2,
    ELSE_3,
    ELSE_TWO_1,
    ELSE_TWO_2,
    ENDIF,
    SELECT,
    CASE_1,
    CASE_2,
    DEFAULT,
    AFTER,
    BEFORE,
    DELETE,
    FIRST,
    LAST,
    INSERT_1,
    INSERT_2,
    NEW,
    NULL,
    OBJECT,
    TYPE,
    FIELD,
    OBJECT_INDEX,
    END_1,
    END_2,
    END_3,
    END_4,
    END_5,
    INCLUDE,
    STOP,
    DATA,
    LOOP_1,
    LOOP_2,
    LOOP_3,
    FOR_1,
    FOR_2,
    FOR_3,
    NEXT,
    WHILE,
    REPEAT_1,
    REPEAT_2,
    MAINLOOP,
    FUNCTION,
    RETURN,
    EXIT,
    MOD,
    NOT,
    AND,
    OR,
    XOR,
    LABEL,
    RESTORE,
    READ,
    HANDLE,
    SAR,
    SHL,
    SHR,
    DATA_TYPE_1,
    DATA_TYPE_2,
    DATA_TYPE_3,
    NUMBER_1,
    NUMBER_2,
    STRING,
    BOOLEAN_1,
    BOOLEAN_2,
    EXPRESSION_1,
    EXPRESSION_2,
    EXPRESSION_3,
    EXPRESSION_4,
    EXPRESSION_5,
    EXPRESSION_6,
    NUMERIC_EXPRESSION_1,
    NUMERIC_EXPRESSION_2,
    NUMERIC_EXPRESSION_3,
    NUMERIC_EXPRESSION_4,
    NUMERIC_EXPRESSION_5,
    STRING_EXPRESSION_1,
    STRING_EXPRESSION_2,
    STRING_EXPRESSION_3,
    STRING_EXPRESSION_4,
    BOOLEAN_EXPRESSION,
    VARIABLE,
    VARIABLE_PLUS_1,
    VARIABLE_PLUS_2,
    ASSIGNMENT,
    PARAMETER_1,
    PARAMETER_2,
    CONDITION_1,
    CONDITION_2,
    CONDITION_3,
    CONDITION_4,
    CONDITION_5,
    CONDITION_6,
    CONDITION_7,
}
export type ROOT = ROOT_1 | ROOT_2 | ROOT_3 | ROOT_4 | ROOT_5 | ROOT_6 | ROOT_7;
export type ROOT_1 = DEFINITION;
export type ROOT_2 = IF;
export type ROOT_3 = SELECT;
export type ROOT_4 = LOOP;
export type ROOT_5 = INCLUDE;
export type ROOT_6 = STOP;
export type ROOT_7 = END;
export type DEFINITION = DEFINITION_1 | DEFINITION_2 | DEFINITION_3 | DEFINITION_4;
export type DEFINITION_1 = GLOBAL;
export type DEFINITION_2 = LOCAL;
export type DEFINITION_3 = CONST;
export type DEFINITION_4 = DIM;
export interface GLOBAL {
    kind: ASTKinds.GLOBAL;
    variable: VARIABLE;
    next: Nullable<ROOT>;
}
export interface LOCAL {
    kind: ASTKinds.LOCAL;
    variable: VARIABLE;
    next: Nullable<ROOT>;
}
export interface CONST {
    kind: ASTKinds.CONST;
    constant: VARIABLE;
    next: Nullable<ROOT>;
}
export interface DIM {
    kind: ASTKinds.DIM;
}
export interface IF {
    kind: ASTKinds.IF;
    condition: CONDITION;
}
export type ELSE = ELSE_1 | ELSE_2 | ELSE_3;
export type ELSE_1 = string;
export interface ELSE_2 {
    kind: ASTKinds.ELSE_2;
}
export interface ELSE_3 {
    kind: ASTKinds.ELSE_3;
}
export type ELSE_TWO = ELSE_TWO_1 | ELSE_TWO_2;
export interface ELSE_TWO_1 {
    kind: ASTKinds.ELSE_TWO_1;
}
export interface ELSE_TWO_2 {
    kind: ASTKinds.ELSE_TWO_2;
}
export type ENDIF = string;
export interface SELECT {
    kind: ASTKinds.SELECT;
    expression: EXPRESSION;
}
export type CASE = CASE_1 | CASE_2;
export interface CASE_1 {
    kind: ASTKinds.CASE_1;
}
export interface CASE_2 {
    kind: ASTKinds.CASE_2;
}
export type DEFAULT = string;
export interface AFTER {
    kind: ASTKinds.AFTER;
}
export interface BEFORE {
    kind: ASTKinds.BEFORE;
}
export interface DELETE {
    kind: ASTKinds.DELETE;
}
export interface FIRST {
    kind: ASTKinds.FIRST;
}
export interface LAST {
    kind: ASTKinds.LAST;
}
export type INSERT = INSERT_1 | INSERT_2;
export interface INSERT_1 {
    kind: ASTKinds.INSERT_1;
}
export interface INSERT_2 {
    kind: ASTKinds.INSERT_2;
}
export interface NEW {
    kind: ASTKinds.NEW;
}
export type NULL = string;
export interface OBJECT {
    kind: ASTKinds.OBJECT;
}
export interface TYPE {
    kind: ASTKinds.TYPE;
}
export interface FIELD {
    kind: ASTKinds.FIELD;
}
export type OBJECT_INDEX = string;
export type END = END_1 | END_2 | END_3 | END_4 | END_5;
export type END_1 = string;
export type END_2 = string;
export type END_3 = string;
export type END_4 = string;
export type END_5 = string;
export interface INCLUDE {
    kind: ASTKinds.INCLUDE;
}
export type STOP = string;
export interface DATA {
    kind: ASTKinds.DATA;
}
export type LOOP = LOOP_1 | LOOP_2 | LOOP_3;
export type LOOP_1 = FOR;
export type LOOP_2 = WHILE;
export type LOOP_3 = REPEAT;
export type FOR = FOR_1 | FOR_2 | FOR_3;
export interface FOR_1 {
    kind: ASTKinds.FOR_1;
}
export interface FOR_2 {
    kind: ASTKinds.FOR_2;
}
export interface FOR_3 {
    kind: ASTKinds.FOR_3;
}
export type NEXT = string;
export interface WHILE {
    kind: ASTKinds.WHILE;
}
export type REPEAT = REPEAT_1 | REPEAT_2;
export interface REPEAT_1 {
    kind: ASTKinds.REPEAT_1;
}
export interface REPEAT_2 {
    kind: ASTKinds.REPEAT_2;
}
export type MAINLOOP = string;
export interface FUNCTION {
    kind: ASTKinds.FUNCTION;
}
export interface RETURN {
    kind: ASTKinds.RETURN;
}
export type EXIT = string;
export interface MOD {
    kind: ASTKinds.MOD;
}
export interface NOT {
    kind: ASTKinds.NOT;
}
export interface AND {
    kind: ASTKinds.AND;
}
export interface OR {
    kind: ASTKinds.OR;
}
export interface XOR {
    kind: ASTKinds.XOR;
}
export interface LABEL {
    kind: ASTKinds.LABEL;
}
export interface RESTORE {
    kind: ASTKinds.RESTORE;
}
export interface READ {
    kind: ASTKinds.READ;
}
export interface HANDLE {
    kind: ASTKinds.HANDLE;
}
export interface SAR {
    kind: ASTKinds.SAR;
}
export interface SHL {
    kind: ASTKinds.SHL;
}
export interface SHR {
    kind: ASTKinds.SHR;
}
export type DATA_TYPE = DATA_TYPE_1 | DATA_TYPE_2 | DATA_TYPE_3;
export type DATA_TYPE_1 = NUMBER;
export type DATA_TYPE_2 = STRING;
export type DATA_TYPE_3 = BOOLEAN;
export type NUMBER = NUMBER_1 | NUMBER_2;
export type NUMBER_1 = string;
export type NUMBER_2 = string;
export type STRING = string;
export type BOOLEAN = BOOLEAN_1 | BOOLEAN_2;
export type BOOLEAN_1 = string;
export type BOOLEAN_2 = string;
export type EXPRESSION = EXPRESSION_1 | EXPRESSION_2 | EXPRESSION_3 | EXPRESSION_4 | EXPRESSION_5 | EXPRESSION_6;
export type EXPRESSION_1 = NUMERIC_EXPRESSION;
export type EXPRESSION_2 = STRING_EXPRESSION;
export type EXPRESSION_3 = BOOLEAN_EXPRESSION;
export type EXPRESSION_4 = BOOLEAN;
export type EXPRESSION_5 = NUMBER;
export type EXPRESSION_6 = STRING;
export type NUMERIC_EXPRESSION = NUMERIC_EXPRESSION_1 | NUMERIC_EXPRESSION_2 | NUMERIC_EXPRESSION_3 | NUMERIC_EXPRESSION_4 | NUMERIC_EXPRESSION_5;
export interface NUMERIC_EXPRESSION_1 {
    kind: ASTKinds.NUMERIC_EXPRESSION_1;
}
export interface NUMERIC_EXPRESSION_2 {
    kind: ASTKinds.NUMERIC_EXPRESSION_2;
}
export interface NUMERIC_EXPRESSION_3 {
    kind: ASTKinds.NUMERIC_EXPRESSION_3;
}
export interface NUMERIC_EXPRESSION_4 {
    kind: ASTKinds.NUMERIC_EXPRESSION_4;
}
export interface NUMERIC_EXPRESSION_5 {
    kind: ASTKinds.NUMERIC_EXPRESSION_5;
}
export type STRING_EXPRESSION = STRING_EXPRESSION_1 | STRING_EXPRESSION_2 | STRING_EXPRESSION_3 | STRING_EXPRESSION_4;
export type STRING_EXPRESSION_1 = STRING;
export interface STRING_EXPRESSION_2 {
    kind: ASTKinds.STRING_EXPRESSION_2;
}
export interface STRING_EXPRESSION_3 {
    kind: ASTKinds.STRING_EXPRESSION_3;
}
export interface STRING_EXPRESSION_4 {
    kind: ASTKinds.STRING_EXPRESSION_4;
}
export type BOOLEAN_EXPRESSION = BOOLEAN;
export type VARIABLE = string;
export type VARIABLE_PLUS = VARIABLE_PLUS_1 | VARIABLE_PLUS_2;
export type VARIABLE_PLUS_1 = VARIABLE;
export interface VARIABLE_PLUS_2 {
    kind: ASTKinds.VARIABLE_PLUS_2;
}
export interface ASSIGNMENT {
    kind: ASTKinds.ASSIGNMENT;
    VARIABLE: EXPRESSION;
}
export type PARAMETER = PARAMETER_1 | PARAMETER_2;
export type PARAMETER_1 = VARIABLE;
export type PARAMETER_2 = ASSIGNMENT;
export type CONDITION = CONDITION_1 | CONDITION_2 | CONDITION_3 | CONDITION_4 | CONDITION_5 | CONDITION_6 | CONDITION_7;
export type CONDITION_1 = BOOLEAN_EXPRESSION;
export interface CONDITION_2 {
    kind: ASTKinds.CONDITION_2;
}
export interface CONDITION_3 {
    kind: ASTKinds.CONDITION_3;
}
export interface CONDITION_4 {
    kind: ASTKinds.CONDITION_4;
}
export interface CONDITION_5 {
    kind: ASTKinds.CONDITION_5;
}
export interface CONDITION_6 {
    kind: ASTKinds.CONDITION_6;
}
export interface CONDITION_7 {
    kind: ASTKinds.CONDITION_7;
}
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public matchROOT($$dpth: number, cr?: ContextRecorder): Nullable<ROOT> {
        return this.choice<ROOT>([
            () => this.matchROOT_1($$dpth + 1, cr),
            () => this.matchROOT_2($$dpth + 1, cr),
            () => this.matchROOT_3($$dpth + 1, cr),
            () => this.matchROOT_4($$dpth + 1, cr),
            () => this.matchROOT_5($$dpth + 1, cr),
            () => this.matchROOT_6($$dpth + 1, cr),
            () => this.matchROOT_7($$dpth + 1, cr),
        ]);
    }
    public matchROOT_1($$dpth: number, cr?: ContextRecorder): Nullable<ROOT_1> {
        return this.matchDEFINITION($$dpth + 1, cr);
    }
    public matchROOT_2($$dpth: number, cr?: ContextRecorder): Nullable<ROOT_2> {
        return this.matchIF($$dpth + 1, cr);
    }
    public matchROOT_3($$dpth: number, cr?: ContextRecorder): Nullable<ROOT_3> {
        return this.matchSELECT($$dpth + 1, cr);
    }
    public matchROOT_4($$dpth: number, cr?: ContextRecorder): Nullable<ROOT_4> {
        return this.matchLOOP($$dpth + 1, cr);
    }
    public matchROOT_5($$dpth: number, cr?: ContextRecorder): Nullable<ROOT_5> {
        return this.matchINCLUDE($$dpth + 1, cr);
    }
    public matchROOT_6($$dpth: number, cr?: ContextRecorder): Nullable<ROOT_6> {
        return this.matchSTOP($$dpth + 1, cr);
    }
    public matchROOT_7($$dpth: number, cr?: ContextRecorder): Nullable<ROOT_7> {
        return this.matchEND($$dpth + 1, cr);
    }
    public matchDEFINITION($$dpth: number, cr?: ContextRecorder): Nullable<DEFINITION> {
        return this.choice<DEFINITION>([
            () => this.matchDEFINITION_1($$dpth + 1, cr),
            () => this.matchDEFINITION_2($$dpth + 1, cr),
            () => this.matchDEFINITION_3($$dpth + 1, cr),
            () => this.matchDEFINITION_4($$dpth + 1, cr),
        ]);
    }
    public matchDEFINITION_1($$dpth: number, cr?: ContextRecorder): Nullable<DEFINITION_1> {
        return this.matchGLOBAL($$dpth + 1, cr);
    }
    public matchDEFINITION_2($$dpth: number, cr?: ContextRecorder): Nullable<DEFINITION_2> {
        return this.matchLOCAL($$dpth + 1, cr);
    }
    public matchDEFINITION_3($$dpth: number, cr?: ContextRecorder): Nullable<DEFINITION_3> {
        return this.matchCONST($$dpth + 1, cr);
    }
    public matchDEFINITION_4($$dpth: number, cr?: ContextRecorder): Nullable<DEFINITION_4> {
        return this.matchDIM($$dpth + 1, cr);
    }
    public matchGLOBAL($$dpth: number, cr?: ContextRecorder): Nullable<GLOBAL> {
        return this.runner<GLOBAL>($$dpth,
            (log) => {
                if (log) {
                    log("GLOBAL");
                }
                let variable: Nullable<VARIABLE>;
                let next: Nullable<Nullable<ROOT>>;
                let res: Nullable<GLOBAL> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[ ]*[gG][lL][oO][bB][aA][lL][ ]+)`, $$dpth + 1, cr) !== null
                    && (variable = this.matchVARIABLE($$dpth + 1, cr)) !== null
                    && ((this.regexAccept(String.raw`(?:[ ])`, $$dpth + 1, cr)) || true)
                    && ((next = this.matchROOT($$dpth + 1, cr)) || true)
                ) {
                    res = {kind: ASTKinds.GLOBAL, variable, next};
                }
                return res;
            }, cr)();
    }
    public matchLOCAL($$dpth: number, cr?: ContextRecorder): Nullable<LOCAL> {
        return this.runner<LOCAL>($$dpth,
            (log) => {
                if (log) {
                    log("LOCAL");
                }
                let variable: Nullable<VARIABLE>;
                let next: Nullable<Nullable<ROOT>>;
                let res: Nullable<LOCAL> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[ ]*[lL][oO][cC][aA][lL][ ]+)`, $$dpth + 1, cr) !== null
                    && (variable = this.matchVARIABLE($$dpth + 1, cr)) !== null
                    && ((this.regexAccept(String.raw`(?:[ ])`, $$dpth + 1, cr)) || true)
                    && ((next = this.matchROOT($$dpth + 1, cr)) || true)
                ) {
                    res = {kind: ASTKinds.LOCAL, variable, next};
                }
                return res;
            }, cr)();
    }
    public matchCONST($$dpth: number, cr?: ContextRecorder): Nullable<CONST> {
        return this.runner<CONST>($$dpth,
            (log) => {
                if (log) {
                    log("CONST");
                }
                let constant: Nullable<VARIABLE>;
                let next: Nullable<Nullable<ROOT>>;
                let res: Nullable<CONST> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[ ]*[cC][oO][nN][sS][tT][ ]+)`, $$dpth + 1, cr) !== null
                    && (constant = this.matchVARIABLE($$dpth + 1, cr)) !== null
                    && ((this.regexAccept(String.raw`(?:[ ])`, $$dpth + 1, cr)) || true)
                    && ((next = this.matchROOT($$dpth + 1, cr)) || true)
                ) {
                    res = {kind: ASTKinds.CONST, constant, next};
                }
                return res;
            }, cr)();
    }
    public matchDIM($$dpth: number, cr?: ContextRecorder): Nullable<DIM> {
        return this.runner<DIM>($$dpth,
            (log) => {
                if (log) {
                    log("DIM");
                }
                let res: Nullable<DIM> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[dD][iI][mM])`, $$dpth + 1, cr) !== null
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.DIM, };
                }
                return res;
            }, cr)();
    }
    public matchIF($$dpth: number, cr?: ContextRecorder): Nullable<IF> {
        return this.runner<IF>($$dpth,
            (log) => {
                if (log) {
                    log("IF");
                }
                let condition: Nullable<CONDITION>;
                let res: Nullable<IF> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[ ]*[iI][fF][ ]+)`, $$dpth + 1, cr) !== null
                    && (condition = this.matchCONDITION($$dpth + 1, cr)) !== null
                    && this.regexAccept(String.raw`(?:[ ]+)`, $$dpth + 1, cr) !== null
                    && ((this.regexAccept(String.raw`(?:[tT][hH][eE][nN][ ]+)`, $$dpth + 1, cr)) || true)
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                    && ((this.regexAccept(String.raw`(?:[ ]+[eE][nN][dD][ ]*[iI][fF])`, $$dpth + 1, cr)) || true)
                ) {
                    res = {kind: ASTKinds.IF, condition};
                }
                return res;
            }, cr)();
    }
    public matchELSE($$dpth: number, cr?: ContextRecorder): Nullable<ELSE> {
        return this.choice<ELSE>([
            () => this.matchELSE_1($$dpth + 1, cr),
            () => this.matchELSE_2($$dpth + 1, cr),
            () => this.matchELSE_3($$dpth + 1, cr),
        ]);
    }
    public matchELSE_1($$dpth: number, cr?: ContextRecorder): Nullable<ELSE_1> {
        return this.regexAccept(String.raw`(?:[eE][lL][sS][eE])`, $$dpth + 1, cr);
    }
    public matchELSE_2($$dpth: number, cr?: ContextRecorder): Nullable<ELSE_2> {
        return this.runner<ELSE_2>($$dpth,
            (log) => {
                if (log) {
                    log("ELSE_2");
                }
                let res: Nullable<ELSE_2> = null;
                if (true
                    && this.regexAccept(String.raw`(?:Else If)`, $$dpth + 1, cr) !== null
                    && this.matchCONDITION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.ELSE_2, };
                }
                return res;
            }, cr)();
    }
    public matchELSE_3($$dpth: number, cr?: ContextRecorder): Nullable<ELSE_3> {
        return this.runner<ELSE_3>($$dpth,
            (log) => {
                if (log) {
                    log("ELSE_3");
                }
                let res: Nullable<ELSE_3> = null;
                if (true
                    && this.regexAccept(String.raw`(?:Else If)`, $$dpth + 1, cr) !== null
                    && this.matchCONDITION($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:Then)`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.ELSE_3, };
                }
                return res;
            }, cr)();
    }
    public matchELSE_TWO($$dpth: number, cr?: ContextRecorder): Nullable<ELSE_TWO> {
        return this.choice<ELSE_TWO>([
            () => this.matchELSE_TWO_1($$dpth + 1, cr),
            () => this.matchELSE_TWO_2($$dpth + 1, cr),
        ]);
    }
    public matchELSE_TWO_1($$dpth: number, cr?: ContextRecorder): Nullable<ELSE_TWO_1> {
        return this.runner<ELSE_TWO_1>($$dpth,
            (log) => {
                if (log) {
                    log("ELSE_TWO_1");
                }
                let res: Nullable<ELSE_TWO_1> = null;
                if (true
                    && this.regexAccept(String.raw`(?:ElseIf)`, $$dpth + 1, cr) !== null
                    && this.matchCONDITION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.ELSE_TWO_1, };
                }
                return res;
            }, cr)();
    }
    public matchELSE_TWO_2($$dpth: number, cr?: ContextRecorder): Nullable<ELSE_TWO_2> {
        return this.runner<ELSE_TWO_2>($$dpth,
            (log) => {
                if (log) {
                    log("ELSE_TWO_2");
                }
                let res: Nullable<ELSE_TWO_2> = null;
                if (true
                    && this.regexAccept(String.raw`(?:ElseIf)`, $$dpth + 1, cr) !== null
                    && this.matchCONDITION($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:Then)`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.ELSE_TWO_2, };
                }
                return res;
            }, cr)();
    }
    public matchENDIF($$dpth: number, cr?: ContextRecorder): Nullable<ENDIF> {
        return this.regexAccept(String.raw`(?:EndIf)`, $$dpth + 1, cr);
    }
    public matchSELECT($$dpth: number, cr?: ContextRecorder): Nullable<SELECT> {
        return this.runner<SELECT>($$dpth,
            (log) => {
                if (log) {
                    log("SELECT");
                }
                let expression: Nullable<EXPRESSION>;
                let res: Nullable<SELECT> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[ ]*[sS][eE][lL][eE][cC][tT][ ]+)`, $$dpth + 1, cr) !== null
                    && (expression = this.matchEXPRESSION($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.SELECT, expression};
                }
                return res;
            }, cr)();
    }
    public matchCASE($$dpth: number, cr?: ContextRecorder): Nullable<CASE> {
        return this.choice<CASE>([
            () => this.matchCASE_1($$dpth + 1, cr),
            () => this.matchCASE_2($$dpth + 1, cr),
        ]);
    }
    public matchCASE_1($$dpth: number, cr?: ContextRecorder): Nullable<CASE_1> {
        return this.runner<CASE_1>($$dpth,
            (log) => {
                if (log) {
                    log("CASE_1");
                }
                let res: Nullable<CASE_1> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[ ]*[cC][aA][sS][eE][ ]+)`, $$dpth + 1, cr) !== null
                    && this.loop<VARIABLE>(() => this.matchVARIABLE($$dpth + 1, cr), false) !== null
                ) {
                    res = {kind: ASTKinds.CASE_1, };
                }
                return res;
            }, cr)();
    }
    public matchCASE_2($$dpth: number, cr?: ContextRecorder): Nullable<CASE_2> {
        return this.runner<CASE_2>($$dpth,
            (log) => {
                if (log) {
                    log("CASE_2");
                }
                let res: Nullable<CASE_2> = null;
                if (true
                    && this.regexAccept(String.raw`(?:Case)`, $$dpth + 1, cr) !== null
                    && this.loop<EXPRESSION>(() => this.matchEXPRESSION($$dpth + 1, cr), false) !== null
                ) {
                    res = {kind: ASTKinds.CASE_2, };
                }
                return res;
            }, cr)();
    }
    public matchDEFAULT($$dpth: number, cr?: ContextRecorder): Nullable<DEFAULT> {
        return this.regexAccept(String.raw`(?:[ ]*[dD][eE][fF][aA][uU][lL][tT][ ]+)`, $$dpth + 1, cr);
    }
    public matchAFTER($$dpth: number, cr?: ContextRecorder): Nullable<AFTER> {
        return this.runner<AFTER>($$dpth,
            (log) => {
                if (log) {
                    log("AFTER");
                }
                let res: Nullable<AFTER> = null;
                if (true
                    && this.regexAccept(String.raw`(?:After)`, $$dpth + 1, cr) !== null
                    && ((this.matchOBJECT_INDEX($$dpth + 1, cr)) || true)
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.AFTER, };
                }
                return res;
            }, cr)();
    }
    public matchBEFORE($$dpth: number, cr?: ContextRecorder): Nullable<BEFORE> {
        return this.runner<BEFORE>($$dpth,
            (log) => {
                if (log) {
                    log("BEFORE");
                }
                let res: Nullable<BEFORE> = null;
                if (true
                    && this.regexAccept(String.raw`(?:Before)`, $$dpth + 1, cr) !== null
                    && ((this.matchOBJECT_INDEX($$dpth + 1, cr)) || true)
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.BEFORE, };
                }
                return res;
            }, cr)();
    }
    public matchDELETE($$dpth: number, cr?: ContextRecorder): Nullable<DELETE> {
        return this.runner<DELETE>($$dpth,
            (log) => {
                if (log) {
                    log("DELETE");
                }
                let res: Nullable<DELETE> = null;
                if (true
                    && this.regexAccept(String.raw`(?:Delete)`, $$dpth + 1, cr) !== null
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.DELETE, };
                }
                return res;
            }, cr)();
    }
    public matchFIRST($$dpth: number, cr?: ContextRecorder): Nullable<FIRST> {
        return this.runner<FIRST>($$dpth,
            (log) => {
                if (log) {
                    log("FIRST");
                }
                let res: Nullable<FIRST> = null;
                if (true
                    && this.regexAccept(String.raw`(?:First)`, $$dpth + 1, cr) !== null
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.FIRST, };
                }
                return res;
            }, cr)();
    }
    public matchLAST($$dpth: number, cr?: ContextRecorder): Nullable<LAST> {
        return this.runner<LAST>($$dpth,
            (log) => {
                if (log) {
                    log("LAST");
                }
                let res: Nullable<LAST> = null;
                if (true
                    && this.regexAccept(String.raw`(?:Last)`, $$dpth + 1, cr) !== null
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.LAST, };
                }
                return res;
            }, cr)();
    }
    public matchINSERT($$dpth: number, cr?: ContextRecorder): Nullable<INSERT> {
        return this.choice<INSERT>([
            () => this.matchINSERT_1($$dpth + 1, cr),
            () => this.matchINSERT_2($$dpth + 1, cr),
        ]);
    }
    public matchINSERT_1($$dpth: number, cr?: ContextRecorder): Nullable<INSERT_1> {
        return this.runner<INSERT_1>($$dpth,
            (log) => {
                if (log) {
                    log("INSERT_1");
                }
                let res: Nullable<INSERT_1> = null;
                if (true
                    && this.regexAccept(String.raw`(?:Insert)`, $$dpth + 1, cr) !== null
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:Before)`, $$dpth + 1, cr) !== null
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.INSERT_1, };
                }
                return res;
            }, cr)();
    }
    public matchINSERT_2($$dpth: number, cr?: ContextRecorder): Nullable<INSERT_2> {
        return this.runner<INSERT_2>($$dpth,
            (log) => {
                if (log) {
                    log("INSERT_2");
                }
                let res: Nullable<INSERT_2> = null;
                if (true
                    && this.regexAccept(String.raw`(?:Insert)`, $$dpth + 1, cr) !== null
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:After)`, $$dpth + 1, cr) !== null
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.INSERT_2, };
                }
                return res;
            }, cr)();
    }
    public matchNEW($$dpth: number, cr?: ContextRecorder): Nullable<NEW> {
        return this.runner<NEW>($$dpth,
            (log) => {
                if (log) {
                    log("NEW");
                }
                let res: Nullable<NEW> = null;
                if (true
                    && this.regexAccept(String.raw`(?:New)`, $$dpth + 1, cr) !== null
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.NEW, };
                }
                return res;
            }, cr)();
    }
    public matchNULL($$dpth: number, cr?: ContextRecorder): Nullable<NULL> {
        return this.regexAccept(String.raw`(?:Null)`, $$dpth + 1, cr);
    }
    public matchOBJECT($$dpth: number, cr?: ContextRecorder): Nullable<OBJECT> {
        return this.runner<OBJECT>($$dpth,
            (log) => {
                if (log) {
                    log("OBJECT");
                }
                let res: Nullable<OBJECT> = null;
                if (true
                    && this.regexAccept(String.raw`(?:Object.)`, $$dpth + 1, cr) !== null
                    && this.matchTYPE($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.OBJECT, };
                }
                return res;
            }, cr)();
    }
    public matchTYPE($$dpth: number, cr?: ContextRecorder): Nullable<TYPE> {
        return this.runner<TYPE>($$dpth,
            (log) => {
                if (log) {
                    log("TYPE");
                }
                let res: Nullable<TYPE> = null;
                if (true
                    && this.regexAccept(String.raw`(?:Type)`, $$dpth + 1, cr) !== null
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.TYPE, };
                }
                return res;
            }, cr)();
    }
    public matchFIELD($$dpth: number, cr?: ContextRecorder): Nullable<FIELD> {
        return this.runner<FIELD>($$dpth,
            (log) => {
                if (log) {
                    log("FIELD");
                }
                let res: Nullable<FIELD> = null;
                if (true
                    && this.regexAccept(String.raw`(?:Field)`, $$dpth + 1, cr) !== null
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.FIELD, };
                }
                return res;
            }, cr)();
    }
    public matchOBJECT_INDEX($$dpth: number, cr?: ContextRecorder): Nullable<OBJECT_INDEX> {
        return this.regexAccept(String.raw`(?:)`, $$dpth + 1, cr);
    }
    public matchEND($$dpth: number, cr?: ContextRecorder): Nullable<END> {
        return this.choice<END>([
            () => this.matchEND_1($$dpth + 1, cr),
            () => this.matchEND_2($$dpth + 1, cr),
            () => this.matchEND_3($$dpth + 1, cr),
            () => this.matchEND_4($$dpth + 1, cr),
            () => this.matchEND_5($$dpth + 1, cr),
        ]);
    }
    public matchEND_1($$dpth: number, cr?: ContextRecorder): Nullable<END_1> {
        return this.regexAccept(String.raw`(?:[eE][nN][dD])`, $$dpth + 1, cr);
    }
    public matchEND_2($$dpth: number, cr?: ContextRecorder): Nullable<END_2> {
        return this.regexAccept(String.raw`(?:End Type)`, $$dpth + 1, cr);
    }
    public matchEND_3($$dpth: number, cr?: ContextRecorder): Nullable<END_3> {
        return this.regexAccept(String.raw`(?:End Function)`, $$dpth + 1, cr);
    }
    public matchEND_4($$dpth: number, cr?: ContextRecorder): Nullable<END_4> {
        return this.regexAccept(String.raw`(?:End If)`, $$dpth + 1, cr);
    }
    public matchEND_5($$dpth: number, cr?: ContextRecorder): Nullable<END_5> {
        return this.regexAccept(String.raw`(?:End Select)`, $$dpth + 1, cr);
    }
    public matchINCLUDE($$dpth: number, cr?: ContextRecorder): Nullable<INCLUDE> {
        return this.runner<INCLUDE>($$dpth,
            (log) => {
                if (log) {
                    log("INCLUDE");
                }
                let res: Nullable<INCLUDE> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[iI][nN][cC][lL][uU][dD][eE])`, $$dpth + 1, cr) !== null
                    && this.matchSTRING_EXPRESSION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.INCLUDE, };
                }
                return res;
            }, cr)();
    }
    public matchSTOP($$dpth: number, cr?: ContextRecorder): Nullable<STOP> {
        return this.regexAccept(String.raw`(?:[sS][tT][oO][pP])`, $$dpth + 1, cr);
    }
    public matchDATA($$dpth: number, cr?: ContextRecorder): Nullable<DATA> {
        return this.runner<DATA>($$dpth,
            (log) => {
                if (log) {
                    log("DATA");
                }
                let res: Nullable<DATA> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[dD][aA][tT][aA])`, $$dpth + 1, cr) !== null
                    && this.loop<EXPRESSION>(() => this.matchEXPRESSION($$dpth + 1, cr), false) !== null
                ) {
                    res = {kind: ASTKinds.DATA, };
                }
                return res;
            }, cr)();
    }
    public matchLOOP($$dpth: number, cr?: ContextRecorder): Nullable<LOOP> {
        return this.choice<LOOP>([
            () => this.matchLOOP_1($$dpth + 1, cr),
            () => this.matchLOOP_2($$dpth + 1, cr),
            () => this.matchLOOP_3($$dpth + 1, cr),
        ]);
    }
    public matchLOOP_1($$dpth: number, cr?: ContextRecorder): Nullable<LOOP_1> {
        return this.matchFOR($$dpth + 1, cr);
    }
    public matchLOOP_2($$dpth: number, cr?: ContextRecorder): Nullable<LOOP_2> {
        return this.matchWHILE($$dpth + 1, cr);
    }
    public matchLOOP_3($$dpth: number, cr?: ContextRecorder): Nullable<LOOP_3> {
        return this.matchREPEAT($$dpth + 1, cr);
    }
    public matchFOR($$dpth: number, cr?: ContextRecorder): Nullable<FOR> {
        return this.choice<FOR>([
            () => this.matchFOR_1($$dpth + 1, cr),
            () => this.matchFOR_2($$dpth + 1, cr),
            () => this.matchFOR_3($$dpth + 1, cr),
        ]);
    }
    public matchFOR_1($$dpth: number, cr?: ContextRecorder): Nullable<FOR_1> {
        return this.runner<FOR_1>($$dpth,
            (log) => {
                if (log) {
                    log("FOR_1");
                }
                let res: Nullable<FOR_1> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[ ]*[fF][oO][rR])`, $$dpth + 1, cr) !== null
                    && this.matchASSIGNMENT($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:To)`, $$dpth + 1, cr) !== null
                    && this.matchNUMERIC_EXPRESSION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.FOR_1, };
                }
                return res;
            }, cr)();
    }
    public matchFOR_2($$dpth: number, cr?: ContextRecorder): Nullable<FOR_2> {
        return this.runner<FOR_2>($$dpth,
            (log) => {
                if (log) {
                    log("FOR_2");
                }
                let res: Nullable<FOR_2> = null;
                if (true
                    && this.regexAccept(String.raw`(?:For)`, $$dpth + 1, cr) !== null
                    && this.matchASSIGNMENT($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:To)`, $$dpth + 1, cr) !== null
                    && this.matchNUMERIC_EXPRESSION($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:Step)`, $$dpth + 1, cr) !== null
                    && this.matchNUMERIC_EXPRESSION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.FOR_2, };
                }
                return res;
            }, cr)();
    }
    public matchFOR_3($$dpth: number, cr?: ContextRecorder): Nullable<FOR_3> {
        return this.runner<FOR_3>($$dpth,
            (log) => {
                if (log) {
                    log("FOR_3");
                }
                let res: Nullable<FOR_3> = null;
                if (true
                    && this.regexAccept(String.raw`(?:For)`, $$dpth + 1, cr) !== null
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:= Each)`, $$dpth + 1, cr) !== null
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.FOR_3, };
                }
                return res;
            }, cr)();
    }
    public matchNEXT($$dpth: number, cr?: ContextRecorder): Nullable<NEXT> {
        return this.regexAccept(String.raw`(?:[nN][eE][xX][tT])`, $$dpth + 1, cr);
    }
    public matchWHILE($$dpth: number, cr?: ContextRecorder): Nullable<WHILE> {
        return this.runner<WHILE>($$dpth,
            (log) => {
                if (log) {
                    log("WHILE");
                }
                let res: Nullable<WHILE> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[ ]*[wW][hH][iI][lL][eE])`, $$dpth + 1, cr) !== null
                    && this.matchCONDITION($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:[ ]*[wW][eE][nN][dD])`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.WHILE, };
                }
                return res;
            }, cr)();
    }
    public matchREPEAT($$dpth: number, cr?: ContextRecorder): Nullable<REPEAT> {
        return this.choice<REPEAT>([
            () => this.matchREPEAT_1($$dpth + 1, cr),
            () => this.matchREPEAT_2($$dpth + 1, cr),
        ]);
    }
    public matchREPEAT_1($$dpth: number, cr?: ContextRecorder): Nullable<REPEAT_1> {
        return this.runner<REPEAT_1>($$dpth,
            (log) => {
                if (log) {
                    log("REPEAT_1");
                }
                let res: Nullable<REPEAT_1> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[ ]*[rR][eE][pP][eE][aA][tT][ ]+)`, $$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:[uU][nN][tT][iI][lL])`, $$dpth + 1, cr) !== null
                    && this.matchCONDITION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.REPEAT_1, };
                }
                return res;
            }, cr)();
    }
    public matchREPEAT_2($$dpth: number, cr?: ContextRecorder): Nullable<REPEAT_2> {
        return this.runner<REPEAT_2>($$dpth,
            (log) => {
                if (log) {
                    log("REPEAT_2");
                }
                let res: Nullable<REPEAT_2> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[ ]*[rR][eE][pP][eE][aA][tT][ ]+)`, $$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:[fF][oO][rR][eE][vV][eE][rR][ ]*)`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.REPEAT_2, };
                }
                return res;
            }, cr)();
    }
    public matchMAINLOOP($$dpth: number, cr?: ContextRecorder): Nullable<MAINLOOP> {
        return this.regexAccept(String.raw`(?:[ ]*[mM][aA][iI][nN][lL][oO][oO][pP][ ]*)`, $$dpth + 1, cr);
    }
    public matchFUNCTION($$dpth: number, cr?: ContextRecorder): Nullable<FUNCTION> {
        return this.runner<FUNCTION>($$dpth,
            (log) => {
                if (log) {
                    log("FUNCTION");
                }
                let res: Nullable<FUNCTION> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[ ]*[fF][uU][nN][cC][tT][iI][oO][nN])`, $$dpth + 1, cr) !== null
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:\()`, $$dpth + 1, cr) !== null
                    && this.loop<PARAMETER>(() => this.matchPARAMETER($$dpth + 1, cr), true) !== null
                    && this.regexAccept(String.raw`(?:\))`, $$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.FUNCTION, };
                }
                return res;
            }, cr)();
    }
    public matchRETURN($$dpth: number, cr?: ContextRecorder): Nullable<RETURN> {
        return this.runner<RETURN>($$dpth,
            (log) => {
                if (log) {
                    log("RETURN");
                }
                let res: Nullable<RETURN> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[ ]*[rR][eE][tT][uU][rR][nN])`, $$dpth + 1, cr) !== null
                    && ((this.matchEXPRESSION($$dpth + 1, cr)) || true)
                ) {
                    res = {kind: ASTKinds.RETURN, };
                }
                return res;
            }, cr)();
    }
    public matchEXIT($$dpth: number, cr?: ContextRecorder): Nullable<EXIT> {
        return this.regexAccept(String.raw`(?:[ ]*[eE][xX][iI][tT])`, $$dpth + 1, cr);
    }
    public matchMOD($$dpth: number, cr?: ContextRecorder): Nullable<MOD> {
        return this.runner<MOD>($$dpth,
            (log) => {
                if (log) {
                    log("MOD");
                }
                let res: Nullable<MOD> = null;
                if (true
                    && this.matchNUMERIC_EXPRESSION($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:[mM][oO][dD])`, $$dpth + 1, cr) !== null
                    && this.matchNUMERIC_EXPRESSION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.MOD, };
                }
                return res;
            }, cr)();
    }
    public matchNOT($$dpth: number, cr?: ContextRecorder): Nullable<NOT> {
        return this.runner<NOT>($$dpth,
            (log) => {
                if (log) {
                    log("NOT");
                }
                let res: Nullable<NOT> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[nN][oO][tT])`, $$dpth + 1, cr) !== null
                    && this.matchBOOLEAN_EXPRESSION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.NOT, };
                }
                return res;
            }, cr)();
    }
    public matchAND($$dpth: number, cr?: ContextRecorder): Nullable<AND> {
        return this.runner<AND>($$dpth,
            (log) => {
                if (log) {
                    log("AND");
                }
                let res: Nullable<AND> = null;
                if (true
                    && this.matchBOOLEAN_EXPRESSION($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:[aA][nN][dD])`, $$dpth + 1, cr) !== null
                    && this.matchBOOLEAN_EXPRESSION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.AND, };
                }
                return res;
            }, cr)();
    }
    public matchOR($$dpth: number, cr?: ContextRecorder): Nullable<OR> {
        return this.runner<OR>($$dpth,
            (log) => {
                if (log) {
                    log("OR");
                }
                let res: Nullable<OR> = null;
                if (true
                    && this.matchBOOLEAN_EXPRESSION($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:[oO][rR])`, $$dpth + 1, cr) !== null
                    && this.matchBOOLEAN_EXPRESSION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.OR, };
                }
                return res;
            }, cr)();
    }
    public matchXOR($$dpth: number, cr?: ContextRecorder): Nullable<XOR> {
        return this.runner<XOR>($$dpth,
            (log) => {
                if (log) {
                    log("XOR");
                }
                let res: Nullable<XOR> = null;
                if (true
                    && this.matchBOOLEAN_EXPRESSION($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:[xX][oO][rR])`, $$dpth + 1, cr) !== null
                    && this.matchBOOLEAN_EXPRESSION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.XOR, };
                }
                return res;
            }, cr)();
    }
    public matchLABEL($$dpth: number, cr?: ContextRecorder): Nullable<LABEL> {
        return this.runner<LABEL>($$dpth,
            (log) => {
                if (log) {
                    log("LABEL");
                }
                let res: Nullable<LABEL> = null;
                if (true
                    && this.regexAccept(String.raw`(?:.)`, $$dpth + 1, cr) !== null
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.LABEL, };
                }
                return res;
            }, cr)();
    }
    public matchRESTORE($$dpth: number, cr?: ContextRecorder): Nullable<RESTORE> {
        return this.runner<RESTORE>($$dpth,
            (log) => {
                if (log) {
                    log("RESTORE");
                }
                let res: Nullable<RESTORE> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[ ]*[rR][eE][sS][tT][oO][rR][eE])`, $$dpth + 1, cr) !== null
                    && this.matchLABEL($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.RESTORE, };
                }
                return res;
            }, cr)();
    }
    public matchREAD($$dpth: number, cr?: ContextRecorder): Nullable<READ> {
        return this.runner<READ>($$dpth,
            (log) => {
                if (log) {
                    log("READ");
                }
                let res: Nullable<READ> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[ ]*[rR][eE][aA][dD])`, $$dpth + 1, cr) !== null
                    && this.loop<VARIABLE>(() => this.matchVARIABLE($$dpth + 1, cr), false) !== null
                ) {
                    res = {kind: ASTKinds.READ, };
                }
                return res;
            }, cr)();
    }
    public matchHANDLE($$dpth: number, cr?: ContextRecorder): Nullable<HANDLE> {
        return this.runner<HANDLE>($$dpth,
            (log) => {
                if (log) {
                    log("HANDLE");
                }
                let res: Nullable<HANDLE> = null;
                if (true
                    && this.regexAccept(String.raw`(?:[ ]*[hH][aA][nN][dD][lL][eE])`, $$dpth + 1, cr) !== null
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.HANDLE, };
                }
                return res;
            }, cr)();
    }
    public matchSAR($$dpth: number, cr?: ContextRecorder): Nullable<SAR> {
        return this.runner<SAR>($$dpth,
            (log) => {
                if (log) {
                    log("SAR");
                }
                let res: Nullable<SAR> = null;
                if (true
                    && this.matchNUMERIC_EXPRESSION($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:[sS][aA][rR])`, $$dpth + 1, cr) !== null
                    && this.matchNUMERIC_EXPRESSION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.SAR, };
                }
                return res;
            }, cr)();
    }
    public matchSHL($$dpth: number, cr?: ContextRecorder): Nullable<SHL> {
        return this.runner<SHL>($$dpth,
            (log) => {
                if (log) {
                    log("SHL");
                }
                let res: Nullable<SHL> = null;
                if (true
                    && this.matchNUMERIC_EXPRESSION($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:[sS][hH][lL])`, $$dpth + 1, cr) !== null
                    && this.matchNUMERIC_EXPRESSION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.SHL, };
                }
                return res;
            }, cr)();
    }
    public matchSHR($$dpth: number, cr?: ContextRecorder): Nullable<SHR> {
        return this.runner<SHR>($$dpth,
            (log) => {
                if (log) {
                    log("SHR");
                }
                let res: Nullable<SHR> = null;
                if (true
                    && this.matchNUMERIC_EXPRESSION($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:[sS][hH][rR])`, $$dpth + 1, cr) !== null
                    && this.matchNUMERIC_EXPRESSION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.SHR, };
                }
                return res;
            }, cr)();
    }
    public matchDATA_TYPE($$dpth: number, cr?: ContextRecorder): Nullable<DATA_TYPE> {
        return this.choice<DATA_TYPE>([
            () => this.matchDATA_TYPE_1($$dpth + 1, cr),
            () => this.matchDATA_TYPE_2($$dpth + 1, cr),
            () => this.matchDATA_TYPE_3($$dpth + 1, cr),
        ]);
    }
    public matchDATA_TYPE_1($$dpth: number, cr?: ContextRecorder): Nullable<DATA_TYPE_1> {
        return this.matchNUMBER($$dpth + 1, cr);
    }
    public matchDATA_TYPE_2($$dpth: number, cr?: ContextRecorder): Nullable<DATA_TYPE_2> {
        return this.matchSTRING($$dpth + 1, cr);
    }
    public matchDATA_TYPE_3($$dpth: number, cr?: ContextRecorder): Nullable<DATA_TYPE_3> {
        return this.matchBOOLEAN($$dpth + 1, cr);
    }
    public matchNUMBER($$dpth: number, cr?: ContextRecorder): Nullable<NUMBER> {
        return this.choice<NUMBER>([
            () => this.matchNUMBER_1($$dpth + 1, cr),
            () => this.matchNUMBER_2($$dpth + 1, cr),
        ]);
    }
    public matchNUMBER_1($$dpth: number, cr?: ContextRecorder): Nullable<NUMBER_1> {
        return this.regexAccept(String.raw`(?:[+-]?[0-9]+)`, $$dpth + 1, cr);
    }
    public matchNUMBER_2($$dpth: number, cr?: ContextRecorder): Nullable<NUMBER_2> {
        return this.regexAccept(String.raw`(?:[pP][iI])`, $$dpth + 1, cr);
    }
    public matchSTRING($$dpth: number, cr?: ContextRecorder): Nullable<STRING> {
        return this.regexAccept(String.raw`(?:[a-z]+)`, $$dpth + 1, cr);
    }
    public matchBOOLEAN($$dpth: number, cr?: ContextRecorder): Nullable<BOOLEAN> {
        return this.choice<BOOLEAN>([
            () => this.matchBOOLEAN_1($$dpth + 1, cr),
            () => this.matchBOOLEAN_2($$dpth + 1, cr),
        ]);
    }
    public matchBOOLEAN_1($$dpth: number, cr?: ContextRecorder): Nullable<BOOLEAN_1> {
        return this.regexAccept(String.raw`(?:[tT][rR][uU][eE])`, $$dpth + 1, cr);
    }
    public matchBOOLEAN_2($$dpth: number, cr?: ContextRecorder): Nullable<BOOLEAN_2> {
        return this.regexAccept(String.raw`(?:[fF][aA][lL][sS][eE])`, $$dpth + 1, cr);
    }
    public matchEXPRESSION($$dpth: number, cr?: ContextRecorder): Nullable<EXPRESSION> {
        return this.choice<EXPRESSION>([
            () => this.matchEXPRESSION_1($$dpth + 1, cr),
            () => this.matchEXPRESSION_2($$dpth + 1, cr),
            () => this.matchEXPRESSION_3($$dpth + 1, cr),
            () => this.matchEXPRESSION_4($$dpth + 1, cr),
            () => this.matchEXPRESSION_5($$dpth + 1, cr),
            () => this.matchEXPRESSION_6($$dpth + 1, cr),
        ]);
    }
    public matchEXPRESSION_1($$dpth: number, cr?: ContextRecorder): Nullable<EXPRESSION_1> {
        return this.matchNUMERIC_EXPRESSION($$dpth + 1, cr);
    }
    public matchEXPRESSION_2($$dpth: number, cr?: ContextRecorder): Nullable<EXPRESSION_2> {
        return this.matchSTRING_EXPRESSION($$dpth + 1, cr);
    }
    public matchEXPRESSION_3($$dpth: number, cr?: ContextRecorder): Nullable<EXPRESSION_3> {
        return this.matchBOOLEAN_EXPRESSION($$dpth + 1, cr);
    }
    public matchEXPRESSION_4($$dpth: number, cr?: ContextRecorder): Nullable<EXPRESSION_4> {
        return this.matchBOOLEAN($$dpth + 1, cr);
    }
    public matchEXPRESSION_5($$dpth: number, cr?: ContextRecorder): Nullable<EXPRESSION_5> {
        return this.matchNUMBER($$dpth + 1, cr);
    }
    public matchEXPRESSION_6($$dpth: number, cr?: ContextRecorder): Nullable<EXPRESSION_6> {
        return this.matchSTRING($$dpth + 1, cr);
    }
    public matchNUMERIC_EXPRESSION($$dpth: number, cr?: ContextRecorder): Nullable<NUMERIC_EXPRESSION> {
        return this.choice<NUMERIC_EXPRESSION>([
            () => this.matchNUMERIC_EXPRESSION_1($$dpth + 1, cr),
            () => this.matchNUMERIC_EXPRESSION_2($$dpth + 1, cr),
            () => this.matchNUMERIC_EXPRESSION_3($$dpth + 1, cr),
            () => this.matchNUMERIC_EXPRESSION_4($$dpth + 1, cr),
            () => this.matchNUMERIC_EXPRESSION_5($$dpth + 1, cr),
        ]);
    }
    public matchNUMERIC_EXPRESSION_1($$dpth: number, cr?: ContextRecorder): Nullable<NUMERIC_EXPRESSION_1> {
        return this.runner<NUMERIC_EXPRESSION_1>($$dpth,
            (log) => {
                if (log) {
                    log("NUMERIC_EXPRESSION_1");
                }
                let res: Nullable<NUMERIC_EXPRESSION_1> = null;
                if (true
                    && this.matchNUMBER($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:\+)`, $$dpth + 1, cr) !== null
                    && this.matchNUMBER($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.NUMERIC_EXPRESSION_1, };
                }
                return res;
            }, cr)();
    }
    public matchNUMERIC_EXPRESSION_2($$dpth: number, cr?: ContextRecorder): Nullable<NUMERIC_EXPRESSION_2> {
        return this.runner<NUMERIC_EXPRESSION_2>($$dpth,
            (log) => {
                if (log) {
                    log("NUMERIC_EXPRESSION_2");
                }
                let res: Nullable<NUMERIC_EXPRESSION_2> = null;
                if (true
                    && this.matchNUMBER($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:\-)`, $$dpth + 1, cr) !== null
                    && this.matchNUMBER($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.NUMERIC_EXPRESSION_2, };
                }
                return res;
            }, cr)();
    }
    public matchNUMERIC_EXPRESSION_3($$dpth: number, cr?: ContextRecorder): Nullable<NUMERIC_EXPRESSION_3> {
        return this.runner<NUMERIC_EXPRESSION_3>($$dpth,
            (log) => {
                if (log) {
                    log("NUMERIC_EXPRESSION_3");
                }
                let res: Nullable<NUMERIC_EXPRESSION_3> = null;
                if (true
                    && this.matchNUMBER($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:\*)`, $$dpth + 1, cr) !== null
                    && this.matchNUMBER($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.NUMERIC_EXPRESSION_3, };
                }
                return res;
            }, cr)();
    }
    public matchNUMERIC_EXPRESSION_4($$dpth: number, cr?: ContextRecorder): Nullable<NUMERIC_EXPRESSION_4> {
        return this.runner<NUMERIC_EXPRESSION_4>($$dpth,
            (log) => {
                if (log) {
                    log("NUMERIC_EXPRESSION_4");
                }
                let res: Nullable<NUMERIC_EXPRESSION_4> = null;
                if (true
                    && this.matchNUMBER($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:\/)`, $$dpth + 1, cr) !== null
                    && this.matchNUMBER($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.NUMERIC_EXPRESSION_4, };
                }
                return res;
            }, cr)();
    }
    public matchNUMERIC_EXPRESSION_5($$dpth: number, cr?: ContextRecorder): Nullable<NUMERIC_EXPRESSION_5> {
        return this.runner<NUMERIC_EXPRESSION_5>($$dpth,
            (log) => {
                if (log) {
                    log("NUMERIC_EXPRESSION_5");
                }
                let res: Nullable<NUMERIC_EXPRESSION_5> = null;
                if (true
                    && this.matchNUMBER($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:\^)`, $$dpth + 1, cr) !== null
                    && this.matchNUMBER($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.NUMERIC_EXPRESSION_5, };
                }
                return res;
            }, cr)();
    }
    public matchSTRING_EXPRESSION($$dpth: number, cr?: ContextRecorder): Nullable<STRING_EXPRESSION> {
        return this.choice<STRING_EXPRESSION>([
            () => this.matchSTRING_EXPRESSION_1($$dpth + 1, cr),
            () => this.matchSTRING_EXPRESSION_2($$dpth + 1, cr),
            () => this.matchSTRING_EXPRESSION_3($$dpth + 1, cr),
            () => this.matchSTRING_EXPRESSION_4($$dpth + 1, cr),
        ]);
    }
    public matchSTRING_EXPRESSION_1($$dpth: number, cr?: ContextRecorder): Nullable<STRING_EXPRESSION_1> {
        return this.matchSTRING($$dpth + 1, cr);
    }
    public matchSTRING_EXPRESSION_2($$dpth: number, cr?: ContextRecorder): Nullable<STRING_EXPRESSION_2> {
        return this.runner<STRING_EXPRESSION_2>($$dpth,
            (log) => {
                if (log) {
                    log("STRING_EXPRESSION_2");
                }
                let res: Nullable<STRING_EXPRESSION_2> = null;
                if (true
                    && this.matchSTRING($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:\+)`, $$dpth + 1, cr) !== null
                    && this.matchSTRING($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.STRING_EXPRESSION_2, };
                }
                return res;
            }, cr)();
    }
    public matchSTRING_EXPRESSION_3($$dpth: number, cr?: ContextRecorder): Nullable<STRING_EXPRESSION_3> {
        return this.runner<STRING_EXPRESSION_3>($$dpth,
            (log) => {
                if (log) {
                    log("STRING_EXPRESSION_3");
                }
                let res: Nullable<STRING_EXPRESSION_3> = null;
                if (true
                    && this.matchSTRING($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:\+)`, $$dpth + 1, cr) !== null
                    && this.matchNUMBER($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.STRING_EXPRESSION_3, };
                }
                return res;
            }, cr)();
    }
    public matchSTRING_EXPRESSION_4($$dpth: number, cr?: ContextRecorder): Nullable<STRING_EXPRESSION_4> {
        return this.runner<STRING_EXPRESSION_4>($$dpth,
            (log) => {
                if (log) {
                    log("STRING_EXPRESSION_4");
                }
                let res: Nullable<STRING_EXPRESSION_4> = null;
                if (true
                    && this.matchSTRING($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:\+)`, $$dpth + 1, cr) !== null
                    && this.matchBOOLEAN($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.STRING_EXPRESSION_4, };
                }
                return res;
            }, cr)();
    }
    public matchBOOLEAN_EXPRESSION($$dpth: number, cr?: ContextRecorder): Nullable<BOOLEAN_EXPRESSION> {
        return this.matchBOOLEAN($$dpth + 1, cr);
    }
    public matchVARIABLE($$dpth: number, cr?: ContextRecorder): Nullable<VARIABLE> {
        return this.regexAccept(String.raw`(?:[_a-zA-Z]+)`, $$dpth + 1, cr);
    }
    public matchVARIABLE_PLUS($$dpth: number, cr?: ContextRecorder): Nullable<VARIABLE_PLUS> {
        return this.choice<VARIABLE_PLUS>([
            () => this.matchVARIABLE_PLUS_1($$dpth + 1, cr),
            () => this.matchVARIABLE_PLUS_2($$dpth + 1, cr),
        ]);
    }
    public matchVARIABLE_PLUS_1($$dpth: number, cr?: ContextRecorder): Nullable<VARIABLE_PLUS_1> {
        return this.matchVARIABLE($$dpth + 1, cr);
    }
    public matchVARIABLE_PLUS_2($$dpth: number, cr?: ContextRecorder): Nullable<VARIABLE_PLUS_2> {
        return this.runner<VARIABLE_PLUS_2>($$dpth,
            (log) => {
                if (log) {
                    log("VARIABLE_PLUS_2");
                }
                let res: Nullable<VARIABLE_PLUS_2> = null;
                if (true
                    && this.matchVARIABLE($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:,)`, $$dpth + 1, cr) !== null
                    && this.matchVARIABLE_PLUS($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.VARIABLE_PLUS_2, };
                }
                return res;
            }, cr)();
    }
    public matchASSIGNMENT($$dpth: number, cr?: ContextRecorder): Nullable<ASSIGNMENT> {
        return this.runner<ASSIGNMENT>($$dpth,
            (log) => {
                if (log) {
                    log("ASSIGNMENT");
                }
                let VARIABLE: Nullable<EXPRESSION>;
                let res: Nullable<ASSIGNMENT> = null;
                if (true
                    && (VARIABLE = this.matchEXPRESSION($$dpth + 1, cr)) !== null
                ) {
                    res = {kind: ASTKinds.ASSIGNMENT, VARIABLE};
                }
                return res;
            }, cr)();
    }
    public matchPARAMETER($$dpth: number, cr?: ContextRecorder): Nullable<PARAMETER> {
        return this.choice<PARAMETER>([
            () => this.matchPARAMETER_1($$dpth + 1, cr),
            () => this.matchPARAMETER_2($$dpth + 1, cr),
        ]);
    }
    public matchPARAMETER_1($$dpth: number, cr?: ContextRecorder): Nullable<PARAMETER_1> {
        return this.matchVARIABLE($$dpth + 1, cr);
    }
    public matchPARAMETER_2($$dpth: number, cr?: ContextRecorder): Nullable<PARAMETER_2> {
        return this.matchASSIGNMENT($$dpth + 1, cr);
    }
    public matchCONDITION($$dpth: number, cr?: ContextRecorder): Nullable<CONDITION> {
        return this.choice<CONDITION>([
            () => this.matchCONDITION_1($$dpth + 1, cr),
            () => this.matchCONDITION_2($$dpth + 1, cr),
            () => this.matchCONDITION_3($$dpth + 1, cr),
            () => this.matchCONDITION_4($$dpth + 1, cr),
            () => this.matchCONDITION_5($$dpth + 1, cr),
            () => this.matchCONDITION_6($$dpth + 1, cr),
            () => this.matchCONDITION_7($$dpth + 1, cr),
        ]);
    }
    public matchCONDITION_1($$dpth: number, cr?: ContextRecorder): Nullable<CONDITION_1> {
        return this.matchBOOLEAN_EXPRESSION($$dpth + 1, cr);
    }
    public matchCONDITION_2($$dpth: number, cr?: ContextRecorder): Nullable<CONDITION_2> {
        return this.runner<CONDITION_2>($$dpth,
            (log) => {
                if (log) {
                    log("CONDITION_2");
                }
                let res: Nullable<CONDITION_2> = null;
                if (true
                    && this.matchEXPRESSION($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:==)`, $$dpth + 1, cr) !== null
                    && this.matchEXPRESSION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.CONDITION_2, };
                }
                return res;
            }, cr)();
    }
    public matchCONDITION_3($$dpth: number, cr?: ContextRecorder): Nullable<CONDITION_3> {
        return this.runner<CONDITION_3>($$dpth,
            (log) => {
                if (log) {
                    log("CONDITION_3");
                }
                let res: Nullable<CONDITION_3> = null;
                if (true
                    && this.matchEXPRESSION($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:<)`, $$dpth + 1, cr) !== null
                    && this.matchEXPRESSION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.CONDITION_3, };
                }
                return res;
            }, cr)();
    }
    public matchCONDITION_4($$dpth: number, cr?: ContextRecorder): Nullable<CONDITION_4> {
        return this.runner<CONDITION_4>($$dpth,
            (log) => {
                if (log) {
                    log("CONDITION_4");
                }
                let res: Nullable<CONDITION_4> = null;
                if (true
                    && this.matchEXPRESSION($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:>)`, $$dpth + 1, cr) !== null
                    && this.matchEXPRESSION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.CONDITION_4, };
                }
                return res;
            }, cr)();
    }
    public matchCONDITION_5($$dpth: number, cr?: ContextRecorder): Nullable<CONDITION_5> {
        return this.runner<CONDITION_5>($$dpth,
            (log) => {
                if (log) {
                    log("CONDITION_5");
                }
                let res: Nullable<CONDITION_5> = null;
                if (true
                    && this.matchEXPRESSION($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:<=)`, $$dpth + 1, cr) !== null
                    && this.matchEXPRESSION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.CONDITION_5, };
                }
                return res;
            }, cr)();
    }
    public matchCONDITION_6($$dpth: number, cr?: ContextRecorder): Nullable<CONDITION_6> {
        return this.runner<CONDITION_6>($$dpth,
            (log) => {
                if (log) {
                    log("CONDITION_6");
                }
                let res: Nullable<CONDITION_6> = null;
                if (true
                    && this.matchEXPRESSION($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:>=)`, $$dpth + 1, cr) !== null
                    && this.matchEXPRESSION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.CONDITION_6, };
                }
                return res;
            }, cr)();
    }
    public matchCONDITION_7($$dpth: number, cr?: ContextRecorder): Nullable<CONDITION_7> {
        return this.runner<CONDITION_7>($$dpth,
            (log) => {
                if (log) {
                    log("CONDITION_7");
                }
                let res: Nullable<CONDITION_7> = null;
                if (true
                    && this.matchEXPRESSION($$dpth + 1, cr) !== null
                    && this.regexAccept(String.raw`(?:<>)`, $$dpth + 1, cr) !== null
                    && this.matchEXPRESSION($$dpth + 1, cr) !== null
                ) {
                    res = {kind: ASTKinds.CONDITION_7, };
                }
                return res;
            }, cr)();
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchROOT(0);
        const ans = res !== null && this.finished();
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchROOT(0);
        if (res && this.finished()) {
            return new ParseResult(res, null);
        }
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.matchROOT(0, rec);
        return new ParseResult(res, rec.getErr());
    }
    private mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const t = func();
            if (t === null) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private runner<T>($$dpth: number, fn: $$RuleType<T>, cr?: ContextRecorder): $$RuleType<T> {
        return () => {
            const mrk = this.mark();
            const res = cr ? (() => {
                const extraInfo: string[] = [];
                const result = fn((msg: string) => extraInfo.push(msg));
                cr.record(mrk, $$dpth, result, this.negating, extraInfo);
                return result;
            })() : fn();
            if (res !== null) {
                return res;
            }
            this.reset(mrk);
            return null;
        };
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ContextRecorder): Nullable<string> {
        return this.runner<string>(dpth,
            (log) => {
                if (log) {
                    if (this.negating) {
                        log("$$!StrMatch");
                    } else {
                        log("$$StrMatch");
                    }
                    // We substring from 3 to len - 1 to strip off the
                    // non-capture group syntax added as a WebKit workaround
                    log(match.substring(3, match.length - 1));
                }
                const reg = new RegExp(match, "y");
                reg.lastIndex = this.mark().overallPos;
                const res = reg.exec(this.input);
                if (res) {
                    let lineJmp = 0;
                    let lind = -1;
                    for (let i = 0; i < res[0].length; ++i) {
                        if (res[0][i] === "\n") {
                            ++lineJmp;
                            lind = i;
                        }
                    }
                    this.pos = {
                        overallPos: reg.lastIndex,
                        line: this.pos.line + lineJmp,
                        offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
                    };
                    return res[0];
                }
                return null;
            }, cr)();
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export class ParseResult {
    public ast: Nullable<ROOT>;
    public err: Nullable<SyntaxErr>;
    constructor(ast: Nullable<ROOT>, err: Nullable<SyntaxErr>) {
        this.ast = ast;
        this.err = err;
    }
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export class SyntaxErr {
    public pos: PosInfo;
    public exprules: string[];
    public expmatches: string[];
    constructor(pos: PosInfo, exprules: Set<string>, expmatches: Set<string>) {
        this.pos = pos;
        this.exprules = [...exprules];
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Tried to match rules ${this.exprules.join(", ")}. Expected one of ${this.expmatches.map((x) => ` '${x}'`)}`;
    }
}
class ErrorTracker implements ContextRecorder {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private mnd: number = -1;
    private prules: Set<string> = new Set();
    private pmatches: Set<string> = new Set();
    public record(pos: PosInfo, depth: number, result: any, negating: boolean, extraInfo: string[]) {
        if ((result === null) === negating) {
            return;
        }
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.mnd = depth;
            this.pmatches.clear();
            this.prules.clear();
        } else if (pos.overallPos === this.mxpos.overallPos && depth < this.mnd) {
            this.mnd = depth;
            this.prules.clear();
        }
        if (this.mxpos.overallPos === pos.overallPos && extraInfo.length >= 2) {
            if (extraInfo[0] === "$$StrMatch") {
                this.pmatches.add(extraInfo[1]);
            }
            if (extraInfo[0] === "$$!StrMatch") {
                this.pmatches.add(`not ${extraInfo[1]}`);
            }
        }
        if (this.mxpos.overallPos === pos.overallPos && this.mnd === depth) {
            extraInfo.forEach((x) => { if (x !== "$$StrMatch" && x !== "$$!StrMatch") { this.prules.add(x); } });
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1) {
            return new SyntaxErr(this.mxpos, this.prules, this.pmatches);
        }
        return null;
    }
}